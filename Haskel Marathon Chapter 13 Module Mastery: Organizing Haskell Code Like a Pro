ğŸ“¦ Chapter 13 â€“ Module Mastery: Organizing Haskell Code Like a Pro
In Chapter 13, youâ€™ve taken a step toward writing maintainable and modular code by learning about Haskell modules, environments, and namespaces.

âœ… Importing Modules
âœ… Controlling environments and namespace pollution
âœ… Creating your own modules
âœ… Using the Prelude and Standard Libraries

This mini-marathon helps you structure a small Haskell project using custom and standard modules, reinforcing good practices in code organization and reusability.

ğŸ¯ Objectives
ğŸ”¹ Learn to import standard Haskell modules
ğŸ”¹ Create your own .hs files as reusable modules
ğŸ”¹ Explore namespacing using qualified and selective import
ğŸ”¹ Understand the role of Prelude and when to hide it
ğŸ”¹ Structure a real mini project into separate modules

ğŸ§ª What to Deliver
ğŸ“ A folder/project with the following:

At least three custom modules:

Main.hs: The entry point

MathOps.hs: Contains simple math utilities

Greeting.hs: Contains string-based greeting utilities

Proper module declarations and import usage

Demonstration of both qualified and selective imports

Use of at least two standard library modules like:

Data.List, System.IO, or Data.Char

A README.md explaining:

How modules are declared and used

How namespace control was applied

What standard modules were used and why

ğŸ’¡ Bonus Challenges
â­ Use hiding, qualified, and as to control your import behavior
â­ Create a fourth module that re-exports functions from the other two
â­ Use Data.Map or System.Directory in your modules
â­ Demonstrate loading your custom module into ghci
â­ Experiment with hiding Prelude and writing your own basic functions

ğŸ“¦ Build Instructions
âœ… Place each module in its own .hs file
âœ… Run with ghc --make Main.hs or using stack run
âœ… Use ghci for interactive exploration (ghci Main.hs)
âœ… Test selective imports, fully-qualified names, and controlled environments
