ğŸ§  Chapter 18 â€“ Mini-Marathon: Mastering Functors and Lifting
In Chapter 18, you dove deep into abstracting the map function using the Functor type class, and explored how seemingly simple ideas can unlock immense expressive power. Now itâ€™s time to build something to truly grasp the mechanics of <$>, lifting, and nested functors.

ğŸ¯ Objectives
ğŸ”¹ Understand and implement Functor instances for custom types
ğŸ”¹ Explore less intuitive functors like Either a, (,) a, and (->) r
ğŸ”¹ Practice using <$> to lift functions into context
ğŸ”¹ Reinforce how function mapping works for wrapped values
ğŸ”¹ Build confidence navigating nested functor layers

ğŸ§ª What to Deliver
ğŸ“Œ A small Haskell program that:

Defines custom data types and implements valid Functor instances

Demonstrates fmap (or <$>) over various types (Maybe, Either, tuples, functions)

Performs lifting of functions using <$>

Demonstrates nested functor mapping (e.g., fmap . fmap)

Provides output showing behavior of each functor mapping

ğŸ“Œ Include clear notes in comments or a separate README explaining:

Why your Functor instances are lawful (respect identity & composition)

How <$> differs from normal function application

What each mapping operation is doing

ğŸ’¡ Bonus Challenges
â­ Define a Functor for a custom wrapper like Box a, Tree a, or Expr a
â­ Implement nested mapping using fmap . fmap on structures like Maybe [a]
â­ Demonstrate how lifting simplifies transforming values in context
â­ Implement <$ (replace all contents) and demonstrate its use
â­ Use GHCi to test type inference and Functor behavior step-by-step

ğŸ“¦ Build Instructions
âœ… Test your functions in ghci or a project file
âœ… Write pure, reusable functions
âœ… Optional: Organize into modules and package with Cabal or Stack
âœ… Add a README.md that includes:

An overview of your data types and instances

Examples of functor usage and lifting

Explanations for any unintuitive behavior observed
