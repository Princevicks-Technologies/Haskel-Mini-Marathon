ğŸ§  Chapter 19 â€“ Mini-Marathon: Programming with Applicative Functors
In this chapter, you discovered why Applicative functors exist, how they expand on Functor, and how to structure computations that have independent effects. Now letâ€™s build something that makes these concepts come alive.

ğŸ¯ Objectives
ğŸ”¹ Understand the limits of Functor and how Applicative goes further
ğŸ”¹ Learn to apply wrapped functions to wrapped values using <*>
ğŸ”¹ Explore pure and its role in lifting
ğŸ”¹ Apply effects composition in a clean, predictable way
ğŸ”¹ Solidify your understanding of the Applicative laws

ğŸ§ª What to Deliver
ğŸ“Œ A Haskell program that:

Defines or uses a custom type with a lawful Applicative instance

Demonstrates use of <*> for combining multiple values in context

Uses pure to lift regular values

Showcases liftA2, *>, <* and how they differ from monadic sequencing

Outputs a step-by-step explanation of how the effects combine

ğŸ“Œ Include comments or a README.md with:

Explanation of why Applicative is needed beyond Functor

A real-life analogy (e.g., forms with validation, multiple inputs, or optional computations)

Laws (identity, composition, homomorphism, interchange) and how your code respects them

ğŸ’¡ Bonus Challenges
â­ Build a form validator using Maybe, Either, or a custom error type
â­ Combine three or more effects using <*> and liftA3
â­ Use lists as Applicative and show how combinations work
â­ Compare your applicative code with a monadic version â€“ whatâ€™s simpler?
â­ Try an Applicative for a custom type like Validation, Parser, or Expr

ğŸ“¦ Build Instructions
âœ… Write pure functions first and wrap them using pure, <*>, etc.
âœ… Organize reusable parts into modules if needed
âœ… Add a README.md that includes:

Your examples and effects

How Applicative helped with clarity or structure

Short notes on laws or behavior in your program
