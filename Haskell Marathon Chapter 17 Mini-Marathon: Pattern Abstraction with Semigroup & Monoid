ğŸ§  Chapter 17 â€“ Mini-Marathon: Pattern Abstraction with Semigroup & Monoid
In Chapter 17, you explored abstracting patterns in Haskell using type classes like Semigroup and Monoid. These abstractions allow you to define general-purpose combining logic that works across many types.

ğŸ¯ Objectives
ğŸ”¹ Understand what it means to abstract a pattern using type classes
ğŸ”¹ Learn why abstraction matters: reuse, clarity, consistency
ğŸ”¹ Explore and implement Semigroup and Monoid instances
ğŸ”¹ Build small utilities using these abstractions
ğŸ”¹ Practice with <> and mempty in real-world examples

ğŸ§ª What to Deliver
ğŸ“Œ A small Haskell console project that:

Defines your own data type(s)

Implements Semigroup and Monoid instances for them

Demonstrates combining values using <> and default identity with mempty

Shows how abstraction simplifies operations like merging, folding, or aggregating

ğŸ“Œ Include clear comments or documentation on:

What patterns you noticed

How Semigroup/Monoid helped abstract those patterns

Where and why to use them

ğŸ’¡ Bonus Challenges
â­ Create a Transaction or Stats type and define Semigroup and Monoid for it
â­ Use foldMap to combine a list of values into one using Monoid
â­ Compose Monoid instances (e.g., Maybe, Either, or tuple types)
â­ Build a small DSL (domain-specific language) that uses Monoid behind the scenes
â­ Compare manual combination logic vs. abstracted Monoid approach

ğŸ“¦ Build Instructions
âœ… Write and test in ghci or with Cabal/Stack
âœ… Organize your code into modules if necessary
âœ… Add a README.md with:

Description of the problem or data type you abstracted

How Semigroup and Monoid helped

Sample usage/output
